package com.crimecat.backend.schedule.service;

import com.crimecat.backend.config.CacheType;
import com.crimecat.backend.exception.ErrorStatus;
import com.crimecat.backend.schedule.domain.*;
import com.crimecat.backend.schedule.dto.EventCreateRequest;
import com.crimecat.backend.schedule.dto.EventResponse;
import com.crimecat.backend.schedule.dto.PublicEventResponse;
import com.crimecat.backend.schedule.dto.UserCalendarRequest;
import com.crimecat.backend.schedule.repository.EventParticipantRepository;
import com.crimecat.backend.schedule.repository.EventRepository;
import com.crimecat.backend.schedule.repository.UserCalendarRepository;
import com.crimecat.backend.webUser.domain.WebUser;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import net.fortuna.ical4j.data.CalendarBuilder;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.Component;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.property.DtEnd;
import net.fortuna.ical4j.model.property.DtStart;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.annotation.Caching;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.reactive.function.client.WebClient;

import java.io.StringReader;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
public class ScheduleService {
    
    private static final Logger log = LoggerFactory.getLogger(ScheduleService.class);

    private final EventRepository eventRepository;
    private final EventParticipantRepository eventParticipantRepository;
    private final UserCalendarRepository userCalendarRepository;
    private final WebClient.Builder webClientBuilder;
    // private final NotificationService notificationService; // Assuming notification service exists

    @CacheEvict(value = CacheType.SCHEDULE_EVENT_LIST, allEntries = true)
    public Event createEvent(EventCreateRequest request, WebUser currentUser) {
        Event event = Event.builder()
                .creator(currentUser)
                .title(request.getTitle())
                .description(request.getDescription())
                .category(request.getCategory())
                .maxParticipants(request.getMaxParticipants())
                .status(EventStatus.RECRUITING) // Initial status
                .build();
        return eventRepository.save(event);
    }

    @Caching(evict = {
        @CacheEvict(value = CacheType.SCHEDULE_PARTICIPANTS, key = "#eventId.toString()"),
        @CacheEvict(value = CacheType.SCHEDULE_AVAILABILITY, key = "#eventId.toString()"),
        @CacheEvict(value = CacheType.SCHEDULE_EVENT_LIST, allEntries = true)
    })
    public void joinEvent(UUID eventId, WebUser currentUser) {
        Event event = eventRepository.findById(eventId)
                .orElseThrow(() -> ErrorStatus.EVENT_NOT_FOUND.asServiceException());

        if (event.getStatus() != EventStatus.RECRUITING) {
            throw ErrorStatus.EVENT_NOT_RECRUITING.asServiceException();
        }

        // Check if user already joined
        if (eventParticipantRepository.existsByEventAndUser(event, currentUser)) {
            throw ErrorStatus.EVENT_ALREADY_JOINED.asServiceException();
        }

        // Check participant limit
        int currentParticipants = eventParticipantRepository.countByEvent(event);
        if (event.getMaxParticipants() != null && currentParticipants >= event.getMaxParticipants()) {
            throw ErrorStatus.EVENT_FULL.asServiceException();
        }

        EventParticipant participant = EventParticipant.builder()
                .event(event)
                .user(currentUser)
                .status("PENDING") // Initial participant status
                .build();
        eventParticipantRepository.save(participant);

        // TODO: Trigger notification to the event creator
        // notificationService.send(event.getCreator(), currentUser.getNickname() + " has joined your event: " + event.getTitle());

        // Check if the event is now full and update status (after adding the new participant)
        if (event.getMaxParticipants() != null && (currentParticipants + 1) >= event.getMaxParticipants()) {
            event.setStatus(EventStatus.RECRUITMENT_COMPLETE);
            eventRepository.save(event);
        }
    }

    @Transactional(readOnly = true)
    @Cacheable(value = CacheType.SCHEDULE_EVENT_LIST, 
               key = "(#category != null ? #category : 'ALL') + ':' + (#status != null ? #status.name() : 'ALL')")
    public List<EventResponse> getEvents(String category, EventStatus status) {
        List<Event> events;
        if (category != null && status != null) {
            events = eventRepository.findByCategoryAndStatus(category, status);
        } else if (category != null) {
            events = eventRepository.findByCategory(category);
        } else if (status != null) {
            events = eventRepository.findByStatus(status);
        } else {
            events = eventRepository.findAll();
        }

        return events.stream()
                .map(EventResponse::from)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    @Cacheable(value = CacheType.SCHEDULE_EVENT_DETAIL, key = "#eventId.toString()")
    public EventResponse getEvent(UUID eventId) {
        Event event = eventRepository.findById(eventId)
                .orElseThrow(() -> ErrorStatus.EVENT_NOT_FOUND.asServiceException());
        return EventResponse.from(event);
    }

    @Caching(evict = {
        @CacheEvict(value = CacheType.SCHEDULE_ICAL_PARSED, allEntries = true),
        @CacheEvict(value = CacheType.SCHEDULE_AVAILABILITY, allEntries = true),
        @CacheEvict(value = CacheType.SCHEDULE_USER_CALENDAR, key = "#currentUser.id.toString()")
    })
    public void saveUserCalendar(UserCalendarRequest request, WebUser currentUser) {
        Optional<UserCalendar> existingCalendar = userCalendarRepository.findByUser(currentUser);

        UserCalendar calendar = existingCalendar.orElseGet(() -> UserCalendar.builder().user(currentUser).build());
        calendar.setIcalUrl(request.getIcalUrl());

        userCalendarRepository.save(calendar);
    }

    // Helper method to fetch and parse iCal data with event details
    @Cacheable(value = CacheType.SCHEDULE_ICAL_PARSED, key = "#icalUrl.hashCode() + '_detailed'")
    private List<Map<String, Object>> fetchAndParseIcalWithDetails(String icalUrl) {
        log.info("üîç [ICAL_DEBUG] Starting to fetch iCalendar from URL: {}", icalUrl);
        
        WebClient webClient = webClientBuilder.build();
        
        String icalContent;
        try {
            // Create URI directly to avoid double encoding issues
            java.net.URI uri = java.net.URI.create(icalUrl);
            log.debug("üîç [ICAL_DEBUG] Created URI: {}", uri.toString());
            
            icalContent = webClient.get().uri(uri).retrieve().bodyToMono(String.class).block();
        } catch (Exception e) {
            log.error("üîç [ICAL_DEBUG] Failed to fetch iCalendar from URL: {} - {}", icalUrl, e.getMessage(), e);
            return new ArrayList<>();
        }

        List<Map<String, Object>> events = new ArrayList<>();
        if (icalContent == null || icalContent.isEmpty()) {
            log.warn("üîç [ICAL_DEBUG] iCalendar content is null or empty");
            return events;
        }
        
        log.info("üîç [ICAL_DEBUG] iCalendar content length: {}", icalContent.length());
        log.debug("üîç [ICAL_DEBUG] First 500 characters: {}", icalContent.substring(0, Math.min(500, icalContent.length())));

        try {
            CalendarBuilder builder = new CalendarBuilder();
            Calendar calendar = builder.build(new StringReader(icalContent));

            log.info("üîç [ICAL_DEBUG] Starting to parse VEVENT components");
            int eventCount = 0;
            int currentYearEvents = 0;
            
            for (Object component : calendar.getComponents(Component.VEVENT)) {
                VEvent event = (VEvent) component;
                DtStart dtStart = event.getStartDate();
                DtEnd dtEnd = event.getEndDate();
                eventCount++;

                if (dtStart != null && dtEnd != null) {
                    LocalDateTime start = dtStart.getDate().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                    LocalDateTime end = dtEnd.getDate().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                    
                    // ÌòÑÏû¨ Ïó∞ÎèÑ Ïù¥Î≤§Ìä∏Ïù∏ÏßÄ ÌôïÏù∏
                    if (start.getYear() == LocalDateTime.now().getYear()) {
                        currentYearEvents++;
                        log.info("üîç [ICAL_DEBUG] Found {} event: {} on {}", 
                            LocalDateTime.now().getYear(),
                            event.getSummary() != null ? event.getSummary().getValue() : "No title",
                            start.toLocalDate());
                    }
                    
                    Map<String, Object> eventDetails = new HashMap<>();
                    eventDetails.put("startTime", start);
                    eventDetails.put("endTime", end);
                    eventDetails.put("title", event.getSummary() != null ? event.getSummary().getValue() : "Í∞úÏù∏ ÏùºÏ†ï");
                    eventDetails.put("description", event.getDescription() != null ? event.getDescription().getValue() : null);
                    
                    events.add(eventDetails);
                    
                    // Ï≤òÏùå 5Í∞ú Ïù¥Î≤§Ìä∏Ïùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Î°úÍ∑∏
                    if (eventCount <= 5) {
                        log.debug("üîç [ICAL_DEBUG] Event {}: title={}, start={}, end={}", 
                            eventCount,
                            event.getSummary() != null ? event.getSummary().getValue() : "No title",
                            start, end);
                    }
                }
            }
            
            log.info("üîç [ICAL_DEBUG] Parsed {} total events, {} events in {}", 
                eventCount, currentYearEvents, LocalDateTime.now().getYear());
        } catch (Exception e) {
            log.error("Failed to parse iCalendar from URL: {} - {}", icalUrl, e.getMessage(), e);
            // Return empty list to gracefully handle parsing failures
        }
        return events;
    }

    // Helper method to fetch and parse iCal data (for backward compatibility)
    @Cacheable(value = CacheType.SCHEDULE_ICAL_PARSED, key = "#icalUrl.hashCode()")
    private List<LocalDateTime[]> fetchAndParseIcal(String icalUrl) {
        WebClient webClient = webClientBuilder.build();
        
        String icalContent;
        try {
            // Create URI directly to avoid double encoding issues
            java.net.URI uri = java.net.URI.create(icalUrl);
            icalContent = webClient.get().uri(uri).retrieve().bodyToMono(String.class).block();
        } catch (Exception e) {
            log.error("Failed to fetch iCalendar from URL: {} - {}", icalUrl, e.getMessage(), e);
            return new ArrayList<>();
        }

        List<LocalDateTime[]> busyTimes = new ArrayList<>();
        if (icalContent == null || icalContent.isEmpty()) {
            return busyTimes;
        }

        try {
            CalendarBuilder builder = new CalendarBuilder();
            Calendar calendar = builder.build(new StringReader(icalContent));

            for (Object component : calendar.getComponents(Component.VEVENT)) {
                VEvent event = (VEvent) component;
                DtStart dtStart = event.getStartDate();
                DtEnd dtEnd = event.getEndDate();

                if (dtStart != null && dtEnd != null) {
                    LocalDateTime start = dtStart.getDate().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                    LocalDateTime end = dtEnd.getDate().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
                    busyTimes.add(new LocalDateTime[]{start, end});
                }
            }
        } catch (Exception e) {
            log.error("Failed to parse iCalendar from URL: {} - {}", icalUrl, e.getMessage(), e);
            // Return empty list to gracefully handle parsing failures
        }
        return busyTimes;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = CacheType.SCHEDULE_AVAILABILITY, key = "#eventId.toString()")
    public List<LocalDateTime[]> calculateAvailability(UUID eventId) {
        Event event = eventRepository.findById(eventId)
                .orElseThrow(() -> ErrorStatus.EVENT_NOT_FOUND.asServiceException());

        List<EventParticipant> participants = eventParticipantRepository.findByEvent(event);

        // Collect all busy times from participants
        List<LocalDateTime[]> allBusyTimes = new ArrayList<>();
        for (EventParticipant participant : participants) {
            userCalendarRepository.findByUser(participant.getUser()).ifPresent(userCalendar -> {
                allBusyTimes.addAll(fetchAndParseIcal(userCalendar.getIcalUrl()));
            });
        }

        // Sort all busy times by start time
        allBusyTimes.sort(Comparator.comparing(interval -> interval[0]));

        // Merge overlapping busy intervals
        List<LocalDateTime[]> mergedBusyTimes = new ArrayList<>();
        if (allBusyTimes.isEmpty()) {
            return new ArrayList<>(); // No busy times, so all times are free
        }

        LocalDateTime[] currentMerged = allBusyTimes.get(0);
        for (int i = 1; i < allBusyTimes.size(); i++) {
            LocalDateTime[] next = allBusyTimes.get(i);
            if (next[0].isBefore(currentMerged[1]) || next[0].isEqual(currentMerged[1])) {
                // Overlap, merge intervals
                currentMerged[1] = currentMerged[1].isAfter(next[1]) ? currentMerged[1] : next[1];
            } else {
                // No overlap, add current merged and start new one
                mergedBusyTimes.add(currentMerged);
                currentMerged = next;
            }
        }
        mergedBusyTimes.add(currentMerged); // Add the last merged interval

        // Determine a relevant time range for availability (e.g., next 30 days)
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime thirtyDaysLater = now.plusDays(30);

        List<LocalDateTime[]> freeTimes = new ArrayList<>();
        LocalDateTime currentFreeStart = now;

        for (LocalDateTime[] busyInterval : mergedBusyTimes) {
            if (currentFreeStart.isBefore(busyInterval[0])) {
                // There's a free slot before this busy interval
                freeTimes.add(new LocalDateTime[]{currentFreeStart, busyInterval[0]});
            }
            currentFreeStart = currentFreeStart.isAfter(busyInterval[1]) ? currentFreeStart : busyInterval[1];
        }

        // Add any remaining free time after the last busy interval up to thirtyDaysLater
        if (currentFreeStart.isBefore(thirtyDaysLater)) {
            freeTimes.add(new LocalDateTime[]{currentFreeStart, thirtyDaysLater});
        }

        return freeTimes;
    }

    /**
     * Ï∫êÏãú Í∞ÄÎä•Ìïú Ï∞∏Ïó¨Ïûê Î™©Î°ù Ï°∞Ìöå Î©îÏÑúÎìú
     */
    @Transactional(readOnly = true)
    @Cacheable(value = CacheType.SCHEDULE_PARTICIPANTS, key = "#eventId.toString()")
    public List<EventParticipant> getEventParticipants(UUID eventId) {
        Event event = eventRepository.findById(eventId)
                .orElseThrow(() -> ErrorStatus.EVENT_NOT_FOUND.asServiceException());
        return eventParticipantRepository.findByEvent(event);
    }

    /**
     * Ï∫êÏãú Í∞ÄÎä•Ìïú Ï∞∏Ïó¨Ïûê Ïàò Ï°∞Ìöå Î©îÏÑúÎìú
     */
    @Transactional(readOnly = true)
    @Cacheable(value = CacheType.SCHEDULE_PARTICIPANTS, key = "#eventId.toString() + ':count'")
    public int getEventParticipantCount(UUID eventId) {
        Event event = eventRepository.findById(eventId)
                .orElseThrow(() -> ErrorStatus.EVENT_NOT_FOUND.asServiceException());
        return eventParticipantRepository.countByEvent(event);
    }

    /**
     * ÌçºÎ∏îÎ¶≠ APIÏö© ÏùºÏ†ï Î™©Î°ù Ï°∞Ìöå
     * - ÎØºÍ∞êÏ†ïÎ≥¥ Ï†úÏô∏Ìïú Í≥µÍ∞ú Ï†ïÎ≥¥Îßå Î∞òÌôò
     */
    @Transactional(readOnly = true)
    @Cacheable(value = CacheType.SCHEDULE_EVENT_LIST, 
               key = "'public:' + (#category != null ? #category : 'ALL') + ':' + (#status != null ? #status.name() : 'ALL')")
    public List<PublicEventResponse> getPublicEvents(String category, EventStatus status) {
        List<Event> events;
        if (category != null && status != null) {
            events = eventRepository.findByCategoryAndStatus(category, status);
        } else if (category != null) {
            events = eventRepository.findByCategory(category);
        } else if (status != null) {
            events = eventRepository.findByStatus(status);
        } else {
            events = eventRepository.findAll();
        }

        return events.stream()
                .map(PublicEventResponse::from)
                .collect(Collectors.toList());
    }

    /**
     * ÌçºÎ∏îÎ¶≠ APIÏö© ÏùºÏ†ï ÏÉÅÏÑ∏ Ï°∞Ìöå
     * - ÎØºÍ∞êÏ†ïÎ≥¥ Ï†úÏô∏Ìïú Í≥µÍ∞ú Ï†ïÎ≥¥Îßå Î∞òÌôò
     */
    @Transactional(readOnly = true)
    @Cacheable(value = CacheType.SCHEDULE_EVENT_DETAIL, key = "'public:' + #eventId.toString()")
    public PublicEventResponse getPublicEvent(UUID eventId) {
        Event event = eventRepository.findById(eventId)
                .orElseThrow(() -> ErrorStatus.EVENT_NOT_FOUND.asServiceException());
        return PublicEventResponse.from(event);
    }

    /**
     * ÌçºÎ∏îÎ¶≠ APIÏö© ÏùºÏ†ï Í∞ÄÏö©ÏãúÍ∞Ñ Ï°∞Ìöå
     * - Í∞úÏù∏ ÏãùÎ≥Ñ Ï†ïÎ≥¥ ÏóÜÏù¥ Í∞ÄÏö©ÏãúÍ∞ÑÎßå Ï†úÍ≥µ
     * - Í∏∞Ï°¥ calculateAvailability Î©îÏÑúÎìú Ïû¨ÏÇ¨Ïö©
     */
    @Transactional(readOnly = true)
    @Cacheable(value = CacheType.SCHEDULE_AVAILABILITY, key = "'public:' + #eventId.toString()")
    public List<LocalDateTime[]> getPublicAvailability(UUID eventId) {
        // Í∏∞Ï°¥ Î©îÏÑúÎìú Ïû¨ÏÇ¨Ïö© - Ïù¥ÎØ∏ Í∞úÏù∏ ÏãùÎ≥Ñ Ï†ïÎ≥¥ Ìè¨Ìï®ÌïòÏßÄ ÏïäÏùå
        return calculateAvailability(eventId);
    }

    /**
     * ÌçºÎ∏îÎ¶≠ APIÏö© Ï∞∏Ïó¨Ïûê ÏàòÎßå Ï°∞Ìöå
     * - Í∞úÏù∏ ÏãùÎ≥Ñ Ï†ïÎ≥¥ Ï†úÏô∏ÌïòÍ≥† Ï∞∏Ïó¨Ïûê ÏàòÎßå Î∞òÌôò
     */
    @Transactional(readOnly = true)  
    @Cacheable(value = CacheType.SCHEDULE_PARTICIPANTS, key = "'public:' + #eventId.toString() + ':count'")
    public int getPublicParticipantCount(UUID eventId) {
        // Í∏∞Ï°¥ Î©îÏÑúÎìú Ïû¨ÏÇ¨Ïö© - Í∞úÏàòÎßå Î∞òÌôòÌïòÎØÄÎ°ú ÏïàÏ†Ñ
        return getEventParticipantCount(eventId);
    }

    /**
     * ÌäπÏ†ï ÏÇ¨Ïö©ÏûêÏùò ÌäπÏ†ï Í∏∞Í∞Ñ ÎÇ¥ Crime-Cat Ïù¥Î≤§Ìä∏ Ï°∞Ìöå (Ï∂îÏ≤ú ÏãúÏä§ÌÖúÏö©)
     * - ÏãúÏûë ÏãúÍ∞ÑÍ≥º Ï¢ÖÎ£å ÏãúÍ∞ÑÏù¥ ÏûàÎäî ÌôïÏ†ïÎêú ÏùºÏ†ïÎßå Î∞òÌôò
     */
    @Transactional(readOnly = true)
    public List<Event> getUserCrimeCatEventsInRange(UUID userId, LocalDate startDate, LocalDate endDate) {
        WebUser user = WebUser.builder().id(userId).build(); // ÌîÑÎ°ùÏãú Í∞ùÏ≤¥ ÏÉùÏÑ±
        
        // ÏÇ¨Ïö©ÏûêÍ∞Ä Ï∞∏Ïó¨ Ï§ëÏù∏ ÌôúÏÑ± Ïù¥Î≤§Ìä∏ Ï§ëÏóêÏÑú ÌäπÏ†ï Í∏∞Í∞Ñ ÎÇ¥Ïóê ÏûàÎäî Ïù¥Î≤§Ìä∏ Ï°∞Ìöå
        List<EventParticipant> activeParticipants = eventParticipantRepository.findActiveByUser(user);
        
        return activeParticipants.stream()
            .map(EventParticipant::getEvent)
            .filter(event -> event.getStartTime() != null && event.getEndTime() != null) // ÏãúÍ∞ÑÏù¥ ÌôïÏ†ïÎêú Ïù¥Î≤§Ìä∏Îßå
            .filter(event -> {
                LocalDate eventDate = event.getStartTime().toLocalDate();
                return !eventDate.isBefore(startDate) && !eventDate.isAfter(endDate);
            })
            .collect(Collectors.toList());
    }

    /**
     * ÌäπÏ†ï ÏÇ¨Ïö©ÏûêÏùò ÌäπÏ†ï Í∏∞Í∞Ñ ÎÇ¥ iCalendar Ïù¥Î≤§Ìä∏ Ï°∞Ìöå (Ï∫òÎ¶∞Îçî ÌëúÏãúÏö©)
     * - Ïô∏Î∂Ä .ics ÌååÏùºÏóêÏÑú ÌååÏã±Îêú Í∞úÏù∏ ÏùºÏ†ï Î∞òÌôò
     */
    @Transactional(readOnly = true)
    public List<Map<String, Object>> getUserEventsInRange(UUID userId, LocalDate startDate, LocalDate endDate) {
        WebUser user = WebUser.builder().id(userId).build();
        
        // ÏÇ¨Ïö©ÏûêÏùò iCalendar URL Ï°∞Ìöå
        Optional<UserCalendar> userCalendarOpt = userCalendarRepository.findByUser(user);
        if (userCalendarOpt.isEmpty() || userCalendarOpt.get().getIcalUrl() == null) {
            return Collections.emptyList();
        }
        
        String icalUrl = userCalendarOpt.get().getIcalUrl();
        
        try {
            // iCalendar Îç∞Ïù¥ÌÑ∞ ÌååÏã± (ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Ìè¨Ìï®)
            List<Map<String, Object>> icalEvents = fetchAndParseIcalWithDetails(icalUrl);
            
            // ÏßÄÏ†ïÎêú ÎÇ†Ïßú Î≤îÏúÑ ÎÇ¥Ïùò Ïù¥Î≤§Ìä∏Îßå ÌïÑÌÑ∞ÎßÅÌïòÍ≥† API ÏùëÎãµ ÌòïÌÉúÎ°ú Î≥ÄÌôò
            LocalDateTime rangeStart = startDate.atStartOfDay();
            LocalDateTime rangeEnd = endDate.atTime(23, 59, 59);
            
            log.info("üîç [ICAL_FILTER] Filtering events for range: {} to {}", rangeStart, rangeEnd);
            log.info("üîç [ICAL_FILTER] Total parsed events before filtering: {}", icalEvents.size());
            
            AtomicInteger filteredEventCount = new AtomicInteger(0);
            AtomicInteger outOfRangeCount = new AtomicInteger(0);
            
            List<Map<String, Object>> result = icalEvents.stream()
                .filter(eventDetails -> {
                    LocalDateTime eventStart = (LocalDateTime) eventDetails.get("startTime");
                    LocalDateTime eventEnd = (LocalDateTime) eventDetails.get("endTime");
                    
                    // Ïù¥Î≤§Ìä∏Í∞Ä Î≤îÏúÑÏôÄ Í≤πÏπòÎäîÏßÄ ÌôïÏù∏
                    boolean isInRange = eventStart.isBefore(rangeEnd) && eventEnd.isAfter(rangeStart);
                    
                    if (isInRange) {
                        int count = filteredEventCount.incrementAndGet();
                        log.debug("üîç [ICAL_FILTER] Event {} in range: {} from {} to {}", 
                            count,
                            (eventDetails.get("title") != null ? eventDetails.get("title") : "No title"),
                            eventStart, eventEnd);
                    } else {
                        int count = outOfRangeCount.incrementAndGet();
                        if (count <= 3) { // Ï≤òÏùå 3Í∞úÎßå Î°úÍπÖ
                            log.debug("üîç [ICAL_FILTER] Event out of range: {} from {} to {}", 
                                (eventDetails.get("title") != null ? eventDetails.get("title") : "No title"),
                                eventStart, eventEnd);
                        }
                    }
                    
                    return isInRange;
                })
                .map(eventDetails -> {
                    LocalDateTime startTime = (LocalDateTime) eventDetails.get("startTime");
                    LocalDateTime endTime = (LocalDateTime) eventDetails.get("endTime");
                    String title = (String) eventDetails.get("title");
                    
                    Map<String, Object> eventMap = new HashMap<>();
                    eventMap.put("id", "ical_" + startTime.toString().hashCode()); // Í≥†Ïú† ID ÏÉùÏÑ±
                    eventMap.put("title", title != null ? title : "Í∞úÏù∏ ÏùºÏ†ï");
                    eventMap.put("startTime", startTime.toString());
                    eventMap.put("endTime", endTime.toString());
                    eventMap.put("allDay", false);
                    eventMap.put("source", "icalendar"); // Ïù¥Î≤§Ìä∏ ÏÜåÏä§ Íµ¨Î∂Ñ
                    eventMap.put("category", "personal"); // Í∞úÏù∏ ÏùºÏ†ï Ïπ¥ÌÖåÍ≥†Î¶¨
                    return eventMap;
                })
                .collect(Collectors.toList());
                
            // ÏµúÏ¢Ö ÌïÑÌÑ∞ÎßÅ Í≤∞Í≥º ÏöîÏïΩ
            log.info("üîç [ICAL_SUMMARY] Final filtering summary:");
            log.info("üîç [ICAL_SUMMARY] - Events in range: {}", filteredEventCount.get());
            log.info("üîç [ICAL_SUMMARY] - Events out of range: {}", outOfRangeCount.get());
            log.info("üîç [ICAL_SUMMARY] - Total events processed: {}", (filteredEventCount.get() + outOfRangeCount.get()));
            
            return result;
                
        } catch (Exception e) {
            log.error("Failed to fetch iCalendar events for user {}: {}", userId, e.getMessage(), e);
            return Collections.emptyList();
        }
    }

    /**
     * Ïù¥Î≤§Ìä∏ ÏóîÌã∞Ìã∞ Ï°∞Ìöå (Ïª®Ìä∏Î°§Îü¨ÏóêÏÑú ÏÇ¨Ïö©)
     */
    @Transactional(readOnly = true)
    public Event getEventEntity(UUID eventId) {
        return eventRepository.findById(eventId)
                .orElseThrow(() -> ErrorStatus.EVENT_NOT_FOUND.asServiceException());
    }
}
