import React, { useState, useEffect, useMemo } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import remarkBreaks from "remark-breaks";
import rehypeRaw from "rehype-raw";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import {
    vscDarkPlus,
    vs,
} from "react-syntax-highlighter/dist/esm/styles/prism";
import { useTheme } from "@/hooks/useTheme";
import { Copy, Check } from "lucide-react";
import SmartAudioPlayer from "@/components/audio/SmartAudioPlayer";
import { AudioSyntaxParser } from "./AudioSyntaxParser";
import { AudioResolver } from "./AudioResolver";
import { AudioToken, ResolvedAudio } from "./types/AudioTypes";

interface EnhancedMarkdownRendererProps {
    content: string;
    className?: string;
    enableAudioProcessing?: boolean;
}

// Separate component for code blocks (Í∏∞Ï°¥Í≥º ÎèôÏùº)
interface CodeBlockProps {
    inline?: boolean;
    className?: string;
    children?: React.ReactNode;
    isDarkMode: boolean;
    [key: string]: any;
}

const CodeBlock: React.FC<CodeBlockProps> = ({ inline, className, children, isDarkMode, ...props }) => {
    const [copied, setCopied] = useState(false);
    
    if (inline) {
        return (
            <code
                className="bg-gray-200 dark:bg-gray-700 px-1 py-0.5 rounded text-gray-800 dark:text-gray-100"
                {...props}
            >
                {children}
            </code>
        );
    }

    const codeContent = String(children).replace(/\n$/, "");
    const match = /language-(\w+)/.exec(className || "");
    const language = match ? match[1] : "";

    const handleCopy = async () => {
        try {
            await navigator.clipboard.writeText(codeContent);
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
        } catch (err) {
            console.error("Failed to copy text: ", err);
        }
    };

    const cleanCode = () => {
        let code = codeContent;
        code = code
            .replace(/^`+\s*\n/, "")
            .replace(/\n\s*`+$/, "");
        code = code.replace(/^```\w*\s*\n/, "");
        code = code.replace(/\n\s*```$/, "");
        return code;
    };

    return (
        <div className="relative bg-gray-100 dark:bg-gray-800 rounded-md my-2 group overflow-hidden">
            <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity z-10">
                <button
                    onClick={handleCopy}
                    className="bg-gray-200 dark:bg-gray-700 p-2 rounded hover:bg-gray-400 dark:hover:bg-gray-500 transition-colors shadow-md"
                    title="ÏΩîÎìú Î≥µÏÇ¨"
                >
                    {copied ? (
                        <Check className="h-4 w-4 text-green-500" />
                    ) : (
                        <Copy className="h-4 w-4 text-gray-700 dark:text-gray-300" />
                    )}
                </button>
            </div>
            <SyntaxHighlighter
                style={isDarkMode ? vscDarkPlus : vs}
                language={language || "javascript"}
                customStyle={{
                    margin: 0,
                    padding: "12px",
                    borderRadius: "6px",
                    backgroundColor: isDarkMode ? "#1e293b" : "#f3f4f6",
                    fontSize: "1.0rem",
                }}
                codeTagProps={{
                    className: "text-gray-800 dark:text-gray-100 font-mono",
                }}
                showLineNumbers={false}
            >
                {cleanCode()}
            </SyntaxHighlighter>
        </div>
    );
};

// Ïò§ÎîîÏò§ Ïª¥Ìè¨ÎÑåÌä∏ Î†åÎçîÎü¨
interface AudioComponentProps {
    token: AudioToken;
    resolver: AudioResolver;
}

const AudioComponent: React.FC<AudioComponentProps> = ({ token, resolver }) => {
    const [resolvedAudio, setResolvedAudio] = useState<ResolvedAudio | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const resolveAudio = async () => {
            setLoading(true);
            setError(null);
            
            try {
                const resolved = await resolver.resolveAudio(token);
                setResolvedAudio(resolved);
            } catch (err) {
                console.error("Audio resolution failed:", err);
                setError(err instanceof Error ? err.message : "Ïò§ÎîîÏò§Î•º Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
            } finally {
                setLoading(false);
            }
        };

        resolveAudio();

        // Cleanup on unmount
        return () => {
            if (resolvedAudio?.blobUrl && resolvedAudio.blobUrl.startsWith('blob:')) {
                URL.revokeObjectURL(resolvedAudio.blobUrl);
            }
        };
    }, [token, resolver]);

    if (loading) {
        return (
            <div className="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 my-4">
                <div className="animate-pulse flex items-center space-x-4">
                    <div className="rounded-full bg-gray-300 h-10 w-10"></div>
                    <div className="flex-1 space-y-2">
                        <div className="h-4 bg-gray-300 rounded w-3/4"></div>
                        <div className="h-3 bg-gray-300 rounded w-1/2"></div>
                    </div>
                </div>
                <div className="mt-3 text-sm text-gray-500">Ïò§ÎîîÏò§ Î°úÎî© Ï§ë...</div>
            </div>
        );
    }

    if (error) {
        return (
            <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4 my-4">
                <div className="flex items-center">
                    <div className="text-red-500 mr-3">‚ö†Ô∏è</div>
                    <div>
                        <div className="font-medium text-red-800 dark:text-red-200">{token.title}</div>
                        <div className="text-sm text-red-600 dark:text-red-300">{error}</div>
                    </div>
                </div>
            </div>
        );
    }

    if (!resolvedAudio) {
        return null;
    }

    return (
        <div className="my-4">
            <SmartAudioPlayer
                src={resolvedAudio.blobUrl}
                title={resolvedAudio.metadata.title}
                isPrivate={resolvedAudio.metadata.isPrivate}
                duration={resolvedAudio.metadata.duration}
                className="w-full"
            />
        </div>
    );
};

const EnhancedMarkdownRenderer: React.FC<EnhancedMarkdownRendererProps> = ({
    content,
    className,
    enableAudioProcessing = true,
}) => {
    const { theme } = useTheme();
    const isDarkMode = theme === "dark";
    
    // Ïò§ÎîîÏò§ Ï≤òÎ¶¨ Í¥ÄÎ†® ÏÉÅÌÉú
    const [audioParser] = useState(() => new AudioSyntaxParser());
    const [audioResolver] = useState(() => new AudioResolver());
    
    // Ïª®ÌÖêÏ∏† ÌååÏã± Î∞è Ï≤òÎ¶¨
    const { processedContent, audioTokens } = useMemo(() => {
        console.log('üé¨ EnhancedMarkdownRenderer useMemo() START');
        
        // ÏïàÏ†ÑÌïú content Ï≤òÎ¶¨
        const safeContent = content || '';
        console.log('üì• Renderer received content:', JSON.stringify(safeContent));
        console.log('‚ö° enableAudioProcessing:', enableAudioProcessing);
        
        if (!enableAudioProcessing || !safeContent || typeof safeContent !== 'string') {
            console.log('‚è≠Ô∏è  Skipping audio processing, returning as-is');
            const earlyReturn = { processedContent: safeContent, audioTokens: [] };
            console.log('üîç Early return object:', earlyReturn);
            return earlyReturn;
        }
        
        console.log('üéµ Calling audioParser.parseContent()');
        const result = audioParser.parseContent(safeContent);
        console.log('üìä Parser result detailed:');
        console.log('  - Full result object:', result);
        console.log('  - result.content:', JSON.stringify(result.content));
        console.log('  - result.audioTokens:', result.audioTokens);
        console.log('  - typeof result.content:', typeof result.content);
        console.log('  - result.content === undefined:', result.content === undefined);
        console.log('  - Object.keys(result):', Object.keys(result));
        
        // Íµ¨Ï°∞Î∂ÑÌï¥ Ìï†Îãπ Î¨∏Ï†ú ÌôïÏù∏ÏùÑ ÏúÑÌïú Î™ÖÏãúÏ†Å Î∞òÌôò
        const returnObj = {
            processedContent: result.content,  // Î™ÖÏãúÏ†Å Îß§Ìïë
            audioTokens: result.audioTokens
        };
        console.log('üîç Prepared return object:', returnObj);
        console.log('  - returnObj.processedContent:', JSON.stringify(returnObj.processedContent));
        console.log('  - returnObj.audioTokens:', returnObj.audioTokens);
        
        return returnObj;
    }, [content, enableAudioProcessing, audioParser]);
    
    // useMemo Í≤∞Í≥º Í≤ÄÏ¶ù
    console.log('üîç After useMemo destructuring:');
    console.log('  - processedContent:', JSON.stringify(processedContent));
    console.log('  - typeof processedContent:', typeof processedContent);
    console.log('  - processedContent === undefined:', processedContent === undefined);
    console.log('  - audioTokens:', audioTokens);
    console.log('  - audioTokens.length:', audioTokens?.length);

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            audioResolver.cleanup();
        };
    }, [audioResolver]);

    // Ïò§ÎîîÏò§ ÌÜ†ÌÅ∞ÏùÑ React Ïª¥Ìè¨ÎÑåÌä∏Î°ú Î≥ÄÌôò
    const renderContentWithAudio = (markdownContent: string) => {
        console.log('\nüé® renderContentWithAudio() START');
        console.log('üì• Received markdownContent:', JSON.stringify(markdownContent));
        console.log('üéØ audioTokens count:', audioTokens.length);
        console.log('üéØ audioTokens detail:', audioTokens);
        
        // ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
        console.log('üîç markdownContent parameter analysis:');
        console.log('  - markdownContent raw:', markdownContent);
        console.log('  - typeof markdownContent:', typeof markdownContent);
        console.log('  - markdownContent === undefined:', markdownContent === undefined);
        console.log('  - markdownContent === null:', markdownContent === null);
        console.log('  - markdownContent === "":', markdownContent === '');
        
        const safeMarkdownContent = markdownContent || '';
        console.log('‚úÖ safeMarkdownContent:', JSON.stringify(safeMarkdownContent));
        console.log('  - safeMarkdownContent length:', safeMarkdownContent.length);
        
        if (!enableAudioProcessing || audioTokens.length === 0) {
            console.log('‚è≠Ô∏è  No audio processing needed, returning as-is');
            return { content: safeMarkdownContent, placeholders: {} };
        }

        // ÎßàÌÅ¨Îã§Ïö¥ Ïò§ÎîîÏò§ Î¨∏Î≤ïÏùÑ ÏûÑÏãú ÌîåÎ†àÏù¥Ïä§ÌôÄÎçîÎ°ú Î≥ÄÌôò
        let contentWithPlaceholders = safeMarkdownContent;
        const placeholders: { [key: string]: AudioToken } = {};
        const validTokens: AudioToken[] = [];

        console.log('üîÑ Starting token processing...');
        audioTokens.forEach((token, index) => {
            console.log(`\nüéØ Processing token ${index}:`, token);
            
            // Î∞©Ïñ¥Ï†Å Í≤ÄÏ¶ù: ÌïÑÏàò ÌïÑÎìú ÌôïÏù∏
            if (!token || !token.originalMatch || !token.url || !token.title) {
                console.warn(`‚ùå Invalid audio token at index ${index}:`, token);
                return;
            }

            // originalMatchÍ∞Ä ÌòÑÏû¨ ÏΩòÌÖêÏ∏†Ïóê Ïã§Ï†úÎ°ú Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏
            console.log('üîç Checking originalMatch in content:');
            console.log('  - originalMatch:', JSON.stringify(token.originalMatch));
            console.log('  - originalMatch length:', token.originalMatch.length);
            console.log('  - content:', JSON.stringify(contentWithPlaceholders));
            console.log('  - content length:', contentWithPlaceholders.length);
            
            // Î¨∏ÏûêÎ≥Ñ ÎπÑÍµê ÎîîÎ≤ÑÍπÖ
            const isValidMatch = contentWithPlaceholders.includes(token.originalMatch);
            console.log('  - includes() result:', isValidMatch);
            
            if (!isValidMatch) {
                console.warn(`‚ùå Audio token originalMatch not found in content!`);
                console.log('üî¨ Character-level debugging:');
                
                // Ï≤´ 50Ïûê ÎπÑÍµê
                const contentStart = contentWithPlaceholders.substring(0, 50);
                const tokenStart = token.originalMatch.substring(0, 50);
                console.log('  - content start:', JSON.stringify(contentStart));
                console.log('  - token start:', JSON.stringify(tokenStart));
                
                // indexOf ÏãúÎèÑ
                const indexOfResult = contentWithPlaceholders.indexOf(token.originalMatch);
                console.log('  - indexOf result:', indexOfResult);
                
                // Î∂ÄÎ∂Ñ Îß§Ïπò ÏãúÎèÑ
                const titleMatch = contentWithPlaceholders.includes(`[audio:${token.title}]`);
                const urlMatch = contentWithPlaceholders.includes(token.url);
                console.log('  - title portion match:', titleMatch);
                console.log('  - url portion match:', urlMatch);
                
                return;
            }

            console.log('‚úÖ originalMatch found in content, proceeding...');
            const placeholder = `{{AUDIO_PLACEHOLDER_${validTokens.length}}}`;
            placeholders[placeholder] = token;
            console.log('üè∑Ô∏è  Generated placeholder:', placeholder);
            
            try {
                const beforeReplace = contentWithPlaceholders;
                contentWithPlaceholders = contentWithPlaceholders.replace(
                    token.originalMatch,
                    placeholder
                );
                console.log('üîÑ Replace operation:');
                console.log('  - BEFORE:', JSON.stringify(beforeReplace));
                console.log('  - AFTER:', JSON.stringify(contentWithPlaceholders));
                
                validTokens.push(token);
                console.log('‚úÖ Token processed successfully');
            } catch (error) {
                console.error(`üí• Error replacing audio token ${index}:`, error, token);
            }
        });

        // Ïú†Ìö®Ìïú ÌÜ†ÌÅ∞Îßå ÏÇ¨Ïö©ÌïòÎèÑÎ°ù ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        if (validTokens.length !== audioTokens.length) {
            console.warn(`‚ö†Ô∏è Filtered ${audioTokens.length - validTokens.length} invalid audio tokens`);
        }

        const result = {
            content: contentWithPlaceholders,
            placeholders
        };
        
        console.log('üì§ renderContentWithAudio() RESULT:', result);
        return result;
    };

    // renderContentWithAudio Ìò∏Ï∂ú Ï†Ñ ÏµúÏ¢Ö Í≤ÄÏ¶ù
    console.log('üöÄ About to call renderContentWithAudio:');
    console.log('  - processedContent value:', JSON.stringify(processedContent));
    console.log('  - processedContent type:', typeof processedContent);
    console.log('  - processedContent length:', processedContent?.length);
    
    const { content: renderContent, placeholders } = renderContentWithAudio(processedContent);
    
    console.log('üèÅ renderContentWithAudio completed:');
    console.log('  - renderContent:', JSON.stringify(renderContent));
    console.log('  - placeholders keys:', Object.keys(placeholders));

    return (
        <div
            className={
                className ||
                "prose prose-sm max-w-none dark:prose-invert prose-headings:font-semibold prose-p:text-muted-foreground prose-a:text-primary"
            }
        >
            <ReactMarkdown
                remarkPlugins={[remarkGfm, remarkBreaks]}
                rehypePlugins={[rehypeRaw]}
                components={{
                    // ÌîåÎ†àÏù¥Ïä§ÌôÄÎçîÍ∞Ä ÏûàÎäî Îã®ÎùΩÏùÑ divÎ°ú Ï≤òÎ¶¨ÌïòÏó¨ DOM Ï§ëÏ≤© ÏóêÎü¨ Î∞©ÏßÄ
                    p({ children }) {
                        console.log('\nüìÑ ReactMarkdown p() component called');
                        console.log('  - children:', children);
                        console.log('  - typeof children:', typeof children);
                        console.log('  - children length:', React.Children.count(children));
                        console.log('  - placeholders object exists:', !!placeholders);
                        console.log('  - placeholders keys:', Object.keys(placeholders || {}));
                        
                        // Ïò§ÎîîÏò§ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçîÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
                        const hasAudioPlaceholder = React.Children.toArray(children).some(child => 
                            typeof child === 'string' && /{{AUDIO_PLACEHOLDER_\d+}}/.test(child)
                        );
                        
                        console.log('  üéØ Has audio placeholder:', hasAudioPlaceholder);
                        
                        const processedChildren = React.Children.map(children, (child, childIndex) => {
                            console.log(`\nüîç Processing child ${childIndex}:`, child, typeof child);
                            
                            if (typeof child === 'string') {
                                console.log('  üìù String child detected, splitting for placeholders');
                                // ÌîåÎ†àÏù¥Ïä§ÌôÄÎçîÎ•º Ïò§ÎîîÏò§ Ïª¥Ìè¨ÎÑåÌä∏Î°ú ÍµêÏ≤¥
                                const parts = child.split(/({{AUDIO_PLACEHOLDER_\d+}})/);
                                console.log('  üî™ Split result:', parts);
                                console.log('  üìä Parts count:', parts.length);
                                return parts.map((part, partIndex) => {
                                    console.log(`\n  üß© Processing part ${partIndex}:`, JSON.stringify(part));
                                    console.log(`    - part length:`, part.length);
                                    console.log(`    - placeholders exists:`, !!placeholders);
                                    console.log(`    - placeholders[part] exists:`, !!(placeholders && placeholders[part]));
                                    
                                    if (placeholders && placeholders[part]) {
                                        console.log(`    ‚úÖ MATCH! Creating AudioComponent for:`, part);
                                        console.log(`    üéØ Token data:`, placeholders[part]);
                                        return (
                                            <AudioComponent
                                                key={`audio-${partIndex}`}
                                                token={placeholders[part]}
                                                resolver={audioResolver}
                                            />
                                        );
                                    } else {
                                        console.log(`    ‚ùå NO MATCH - returning text:`, JSON.stringify(part));
                                        if (placeholders) {
                                            console.log(`    üîç Available placeholder keys:`, Object.keys(placeholders));
                                            console.log(`    üîç Looking for key:`, JSON.stringify(part));
                                            console.log(`    üîç Key comparison results:`);
                                            Object.keys(placeholders).forEach(key => {
                                                console.log(`      - "${key}" === "${part}":`, key === part);
                                                console.log(`      - "${key}" length:`, key.length, `"${part}" length:`, part.length);
                                            });
                                        }
                                    }
                                    return part || null;
                                });
                            }
                            return child;
                        });

                        console.log('üì§ ReactMarkdown p() returning processed children:', processedChildren);
                        console.log('  üìä Processed children count:', React.Children.count(processedChildren));
                        console.log('  üîç Processed children types:', processedChildren?.map((child, i) => 
                            `${i}: ${typeof child} ${child?.type?.name || 'unknown'}`
                        ));

                        // Ïò§ÎîîÏò§ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçîÍ∞Ä ÏûàÏúºÎ©¥ divÎ°ú, ÏóÜÏúºÎ©¥ pÎ°ú Î†åÎçîÎßÅ
                        if (hasAudioPlaceholder) {
                            return <div className="markdown-paragraph-with-audio">{processedChildren}</div>;
                        } else {
                            return <p>{processedChildren}</p>;
                        }
                    },
                    // Í∏∞Ï°¥ ÏΩîÎìú Î∏îÎ°ù Ï≤òÎ¶¨
                    code(props) {
                        return <CodeBlock {...props} isDarkMode={isDarkMode} />;
                    },
                    // ÍµµÍ∏∞
                    strong({ children }) {
                        return <span className="font-bold">{children}</span>;
                    },
                    // Í∏∞Ïö∏ÏûÑÏ≤¥
                    em({ children }) {
                        return <span className="italic">{children}</span>;
                    },
                    // Ï∑®ÏÜåÏÑ†
                    del({ children }) {
                        return <span className="line-through">{children}</span>;
                    },
                    // Î∞ëÏ§Ñ
                    u({ children }) {
                        return <span className="underline">{children}</span>;
                    },
                    // ÎßÅÌÅ¨ (Ïò§ÎîîÏò§Í∞Ä ÏïÑÎãå ÏùºÎ∞ò ÎßÅÌÅ¨Îßå)
                    a({ href, children }) {
                        // Ïò§ÎîîÏò§ Î¨∏Î≤ïÏù¥Î©¥ Î¨¥Ïãú
                        const childText = React.Children.toArray(children).join('');
                        if (childText.startsWith('audio:')) {
                            return null;
                        }

                        return (
                            <a
                                href={href}
                                className="text-blue-500 hover:underline"
                                target="_blank"
                                rel="noreferrer"
                            >
                                {children}
                            </a>
                        );
                    },
                    // Ïù∏Ïö©Íµ¨
                    blockquote({ children }) {
                        return (
                            <div className="border-l-4 border-gray-300 dark:border-gray-600 pl-3 py-1 my-2">
                                {children}
                            </div>
                        );
                    },
                }}
            >
                {renderContent}
            </ReactMarkdown>
        </div>
    );
};

export default EnhancedMarkdownRenderer;